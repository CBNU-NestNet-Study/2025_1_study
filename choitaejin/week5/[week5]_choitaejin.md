## 📌 (#23) [week5] choitaejin

[수학, 다이나믹 프로그래밍] [24416] 문제풀이
[다이나믹 프로그래밍, 가장 긴 증가하는 부분 수열 문제] [11053] 문제풀이이
[다이나믹 프로그래밍] [2579]문제풀이

---

## ✅ 해결한 문제
- [ ] 문제 1 알고리즘 수업 - 피보나치 수 1 (https://www.acmicpc.net/problem/24416)
- [ ] 문제 2 가장 긴 증가하는 부분 수열 (https://www.acmicpc.net/problem/11053)
- [ ] 문제 3 계단 오르기 (https://www.acmicpc.net/problem/2579)
- [ ] 문제 4 제목 (문제 링크)

---

## 💡 문제 해결 방법 및 핵심 로직
### - 문제 1: 24416
  - 해결 방법:
    - pseudo code로 주어진 두 방법의 피보나치 함수를 구현하고 각 실행 과정마다 횟수를 체크해서
      각각 `return`해주면 된다.
  - 핵심 로직:
    - 횟수를 체크하는 cnt 변수를 선언 후 재귀 과정마다 + 1 씩 해주고 `return cnt;` 해주기

```javascript
  function fib(n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    else {
        return (fib(n - 1) + fib(n - 2));
        cnt++; // 실행할 때마다 실행 횟수 증가
    }

    return cnt; // 실행 횟수 반환
}

function fibonacci(n) {
    let f = new Array(n + 1).fill(0);
    f[1] = f[2] = 1;
    for (let i = 3; i <= n; i++) {
        f[i] = f[i - 1] + f[i - 2];
        cnt++; // 실행할 때마다 실행 횟수 증가
    }
    
    return cnt; // 실행 횟수 반환
}

let input;
let cnt = 0; // 실행 횟수 변수

rl.on('line', (line) => {
    input = parseInt(line);
    rl.close();
}).on('close', () => {
    // 두 피보나치 코드의 실행 횟수를 ' '으로 join해서 한 줄에 출력
    const res = [fib(input), fibonacci(input)].join(' ');

    console.log(res);

    process.exit();
});
```

### - 문제 2: 11053
  - 해결 방법:
    - dp 테이블, 초기값 세팅: 원소 1개로 이루어진 가장 긴 증가하는 부분 수열일 가능성이 있음 (1로 초기화하여 배열 생성)
      - dp 테이블의 값은 해당 index i까지의 수열에서 인덱스 i를 포함한 가장 긴 증가하는 부분 수열의 길이
    - 점화식: 이중 for문으로 `i = 0 to n - 1`, `j = 0 to i` 로 돌리면서 `arr[j] < arr[i]` 인 경우
             (현재 값보다 작은 값이 존재하면 부분 수열) 기존 dp값과 + 1한 값을 비교하여 더 큰 값으로(기존보다 더 긴 증가하는 수열이 존재하면) 갱신

  - 핵심 로직:
    - `dp[i] = Math.max(dp[i], dp[i] + 1);`

```javascript
  .on('close', () => {
    let dp = new Array(n).fill(1); // 1로 초기화 된 dp 배열 생성

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (arr[j] < arr[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1); // 점화식 코드 구현
            }
        }
    }
    
    console.log(Math.max(...dp)); // dp 테이블에서 최대 값 = 가장 긴 증가하는 부분 수열
    process.exit();
});
```

### - 문제 3: 2579
  - 해결 방법:
    - dp테이블 `dp[i][j]`: i는 (i+1)번째 계단까지의 합, j는 연속해서 밟은 계단의 수 (j+1)
    - 점화식: **연속해서 계단을 밟은 경우에 따라 달라진다.**
      - `dp[i][0] = Math.max(dp[i-2][0], dp[i-2][1]) + score[i];` i번째 계단을 밟는데 연속하지 않은 경우: i-2번째 계단에서 올라옴
      - `dp[i][1] = dp[i-1][0] + score[i];` i번째 계단을 연속해서 밟은 경우: i-1번째 계단이 연속되지 않은 상태였어야 함
    - dp테이블 초기값:
      ```javascript
        dp[0][0] = score[0]; // 첫 번째 계단만 밟은 경우 점수
        dp[0][1] = 0; // 첫 번째 계단을 연속으로 밟은 경우는 없으니까 0으로 초기화
        dp[1][0] = score[1]; // 두 번째 계단만 밟은 경우 (첫 번째 건너뛰고 시작하자마자 두번째 계단으로)
        dp[1][1] = score[0] + score[1]; // 첫 번째 밟고 연속으로 두 번째 계단도 밟은 경우
      ```

  - 핵심 로직:
    - `dp[i][0] = Math.max(dp[i-2][0], dp[i-2][1]) + score[i];`
      `dp[i][1] = dp[i-1][0] + score[i];`

```javascript
   let dp = Array(n).fill().map(() => [0, 0]); // dp테이블 [0,0]으로 채워진 2차원 배열로 초기화
    dp[0][0] = score[0]; // 첫 번째 계단만 밟은 경우 점수
    dp[0][1] = 0; // 첫 번째 계단을 연속으로 밟은 경우는 없으니까 0으로 초기화
    
    if (n > 1) {
        dp[1][0] = score[1]; // 두 번째 계단만 밟은 경우(첫 번째 건너뜀)
        dp[1][1] = score[0] + score[1]; // 첫 번째 밟고 연속으로 두 번째 계단도 밟은 경우 (첫 번째 건너뛰고 시작하자마자 두번째 계단으로)
        
        // 세 번째 계단부터 dp 채우기
        for (let i = 2; i < n; i++) {
            // i번째 계단을 밟는데 연속하지 않은 경우: i-2번째 계단에서 올라옴(둘 중 더 큰 값 선택)
            dp[i][0] = Math.max(dp[i-2][0], dp[i-2][1]) + score[i];
            // i번째 계단을 연속해서 밟은 경우: i-1번째 계단이 연속되지 않은 상태였어야 함
            dp[i][1] = dp[i-1][0] + score[i];
        }
    }
    
    // 마지막 계단까지 올라갔을 때 최대 점수 출력 (연속/비연속 중 더 큰 값)
    console.log(Math.max(dp[n-1][0], dp[n-1][1]));

    process.exit();
```

### - 문제 4:
  - 해결 방법:
  - 핵심 로직:
```
  코드를 입력해주세요
```

---

## ✨ 기타 참고 사항
- 예제 입력/출력과 실행 결과 : 

- 고민했던 부분이나 어려웠던 점 :
  - DP 테이블 정의, 점화식 찾기, 초기값 정하기 모두 쉽지 않았다.
  - 문제 풀어도 글로 설명하는게 어렵다. 감으로 풀어서 그런것 같다.
  
- 추가로 개선할 사항 :
  - **24416번:**
    운이 좋아 맞췄다. cnt가 global로 선언되어서 오염될 가능성도 존재했고, 재귀 호출에서는 cnt는 증가하지 않는다. 
    정답 처리된 이유를 찾아보니 피보나치 재귀 호출은 fib(n)이 n == 1 또는 n == 2에 도달하는 횟수는 정확히 n번째 피보나치 수(F(n)) 와 동일해서 정답처리가 되었다.
  - **2579번:**
    연속 3개 계단 금지와 같은 문제의 조건을 포함한 수식 작성이 까다로웠다.
    그래서 2차원 배열로 풀었는데 1차원 배열로도 문제의 조건을 충족하는 방법이 있어서 따로 공부해 봐야겠다.
